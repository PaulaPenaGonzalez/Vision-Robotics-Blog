<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proyecto 1 - Detecci贸n de Bordes</title>
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <h1> Reconstrucci贸n 3D de una escena 2D </h1>
        <p> Progreso y avances de este proyecto. </p>
    </header>

    <!-- Introducci贸n antes de las publicaciones -->
    <div class="container">
    	<p>
        En este proyecto, he desarrollado un sistema de reconstrucci贸n 3D a partir de im谩genes est茅reo, partiendo 煤nicamente de los p铆xeles detectados como bordes en una pareja de c谩maras calibradas. A trav茅s de t茅cnicas cl谩sicas de visi贸n por computador, como la geometr铆a epipolar, la correlaci贸n de ventanas y la triangulaci贸n de rayos, se genera una nube de puntos coloreada que representa la escena capturada por las c谩maras. 
    	</p>
    	<p>
        A continuaci贸n, puedes leer las publicaciones relacionadas con este proyecto, donde se detallan los avances, problemas encontrados y soluciones aplicadas. 
	</p>

	<!-- Imagen de la reconstrucci贸n -->
    	<div style="text-align: center; margin-top: 20px;">
	        <img src="https://raw.githubusercontent.com/PaulaPenaGonzalez/Vision-Robotics-Blog/main/assets/images/proyecto2.jpg" 
	             alt="Reconstrucci贸n 3D a partir de bordes" 
	             style="width: 600px; height: auto; border-radius: 8px;">
    	</div>
    </div>

    <div class="container">
        <h2>Publicaciones - Reconstrucci贸n 3D</h2>
        <button onclick="mostrarPost('Dia1', 1)"> Primer post </button>
        <button onclick="mostrarPost('Dia2', 2)"> Segundo post</button>
        <button onclick="mostrarPost('Dia3', 3)"> Tercer post</button>
        <button onclick="mostrarPost('Dia4', 4)"> Cuarto post: Emparejamiento por correlaci贸n (b煤squeda de hom贸logos) </button>
	<button onclick="mostrarPost('Dia5', 5)"> Quinto post: Triangulaci贸n del punto 3D </button>
	<button onclick="mostrarPost('Dia6', 6)"> Sexto post: Proyecci贸n y visualizaci贸n </button>
	<button onclick="mostrarPost('Dia7', 6)"> S茅ptimo post: Limpieza y refinamiento </button>
    </div>

    <!-- Contenido del primer post -->
    <div id="post_Dia1_1" class="post-container" style="display: none;">
	<h1> Preparaci贸n inicial y lectura de im谩genes </h1>
    	<h2> Objetivo: Cargar y preprocesar las im谩genes est茅reo capturadas por las dos c谩maras calibradas (izquierda y derecha). Fundamental para extraer la informaci贸n visual relevante que servir谩 como base para todo el sistema de reconstrucci贸n 3D.</h2>

    	<h3> Captura de Im谩genes</h3>

    	<p>Las im谩genes izquierda y derecha fueron obtenidas desde el simulador Unibotics. Estas im谩genes corresponden a la misma escena vista desde dos 谩ngulos ligeramente diferentes, lo que permite generar percepci贸n de profundidad gracias al paralaje.</p>

	<div style="text-align: center; margin-top: 20px;">
	        <img src="https://raw.githubusercontent.com/PaulaPenaGonzalez/Vision-Robotics-Blog/main/assets/images/ImagenLImagenR.jpg" 
	             alt="Reconstrucci贸n 3D a partir de bordes" 
	             style="width: 300px; height: auto; border-radius: 8px;">
    	</div>
	    
    	<h3> Conversi贸n a Escala de Grises</h3>
    	<p> Para simplificar el an谩lisis visual y reducir la carga computacional, se realiz贸 una conversi贸n de las im谩genes a escala de grises. Esto permite centrarse en la estructura de la escena sin que el color interfiera en las operaciones iniciales como la detecci贸n de bordes.</p>

    	<h3>Detecci贸n de Bordes</h3>
	<p>La etapa clave en este punto fue aplicar un detector de bordes, espec铆ficamente el m茅todo de Canny. Esta t茅cnica resalta los contornos y l铆neas m谩s relevantes de la escena, permitiendo identificar los puntos caracter铆sticos que luego se utilizar谩n para hallar correspondencias entre ambas im谩genes. Se hizo un ajuste manual de los par谩metros del detector para encontrar un equilibrio entre sensibilidad (captar todos los bordes importantes) y robustez (evitar bordes producidos por ruido o detalles irrelevantes).</p>

	<div style="text-align: center; margin-top: 20px;">
	        <img src="https://raw.githubusercontent.com/PaulaPenaGonzalez/Vision-Robotics-Blog/main/assets/images/Bordes.jpg" 
	             alt="Reconstrucci贸n 3D a partir de bordes" 
	             style="width: 300px; height: auto; border-radius: 8px;">
    	</div>

    	<h3>Visualizaci贸n y Verificaci贸n</h3>
    	<p>Una vez obtenidas las m谩scaras de bordes, se visualizaron ambas im谩genes con sus respectivos contornos resaltados. Esto ayud贸 a comprobar que los par谩metros elegidos proporcionaban una buena base para continuar con la reconstrucci贸n.</p>
    
    </div>

    <!-- Contenido del tercer post -->
    <div id="post_Dia3_3" class="post-container" style="display: none;">
	<h2> Detecci贸n y selecci贸n de puntos caracter铆sticos </h2>
        
	<p>Uno de los pilares de la reconstrucci贸n 3D a partir de visi贸n est茅reo es la <strong>geometr铆a epipolar</strong>. En este post abordamos c贸mo obtener la l铆nea epipolar en la imagen derecha a partir de un punto caracter铆stico detectado en la imagen izquierda.</p>
        
	<h3> Retroproyecci贸n del punto izquierdo </h3>

	<p>Cada punto caracter铆stico extra铆do de la imagen izquierda es transformado a coordenadas del mundo real mediante retroproyecci贸n. Para ello, se utiliza la matriz de proyecci贸n inversa de la c谩mara izquierda, proporcionada por la herramienta <code>HAL.backproject</code>.</p>
        
        <h3>Vector director del rayo</h3>
        <p>Con el punto 3D obtenido y la posici贸n de la c谩mara izquierda, se calcula el vector director del rayo de retroproyecci贸n:</p>
    	<p><code>u = punto_3d - centro_c谩mara</code></p>
    	<p>Este vector se normaliza para definir una direcci贸n en el espacio desde el centro de la c谩mara.</p>
        
        <h3>Proyecci贸n del rayo en la imagen derecha</h3>

	<p>Se seleccionan dos puntos arbitrarios sobre el rayo en 3D (por ejemplo, a cierta distancia a lo largo del vector director) y se proyectan sobre la imagen derecha utilizando la funci贸n <code>HAL.project</code>.</p>
	<p>Posteriormente, se convierten estas coordenadas proyectadas de espacio 贸ptico a espacio gr谩fico con <code>HAL.opticalToGrafic</code>.</p>
	
	<h3> C谩lculo de la l铆nea epipolar</h3>
	<p>Una vez tenemos los dos puntos proyectados en la imagen derecha, la l铆nea epipolar se calcula como la recta que pasa por ambos:</p>
	<p><code>line = np.cross(p1_2d, p2_2d)</code></p>
	<p>Esto nos da los coeficientes <code>(a, b, c)</code> de la recta epipolar en la forma <code>ax + by + c = 0</code>, que se dibujar谩 sobre la imagen derecha para restringir la b煤squeda de hom贸logos a esa l铆nea.</p>
	
	<p>Este paso es clave porque reduce el problema de b煤squeda 2D a uno 1D: solo buscamos hom贸logos a lo largo de una l铆nea, lo cual mejora mucho la eficiencia y precisi贸n.</p>
	
    </div>

    <!--Contenido del segundo post -->
    <div id="post_Dia2_2" class="post-container" style="display: none;">
        <h2> 驴Qu茅 significa detectar puntos caracter铆sticos? </h2>
        <p>En el proceso de reconstrucci贸n 3D, identificar los puntos m谩s relevantes de una imagen es esencial. No todos los p铆xeles aportan informaci贸n 煤til: necesitamos centrarnos en aquellos que definen contornos, estructuras y geometr铆as bien marcadas en la escena. En este post, abordamos c贸mo se extraen estos puntos a partir de una imagen ya procesada por un detector de bordes.</p>
        
        <h3> Selecci贸n a partir de bordes detectados </h3>
	<p>Una vez obtenida la m谩scara de bordes mediante el detector de Canny, lo que tenemos es una imagen en blanco y negro donde los bordes aparecen marcados en blanco (valor alto).</p>
	<p>A partir de aqu铆, el objetivo es localizar las coordenadas de estos p铆xeles blancos que representan los contornos m谩s significativos.</p>
	
	<p>Para ello, se recorre la imagen buscando todas las posiciones en las que el valor del p铆xel supere cierto umbral (en este caso, simplemente donde el valor es mayor que cero). </p>
	<p>Esto nos devuelve las coordenadas (x, y) de los bordes relevantes. As铆 se construye una lista de puntos que actuar谩n como candidatos para buscar correspondencias entre im谩genes izquierda y derecha.</p>
        
        <h3> Un peque帽o extra </h3>
        <p>Durante las pruebas, se decidi贸 no procesar todos los puntos a la vez, sino seleccionar uno de cada pocos (por ejemplo, cada tres puntos). </p>
	<p>Esto ayuda a mantener el rendimiento y obtener una nube de puntos m谩s limpia y distribuida de forma uniforme. Con esta lista de puntos caracter铆stica ya lista, estamos preparados para pasar al siguiente paso: proyectar cada uno de ellos y buscar su hom贸logo en la segunda imagen </p>
        
    </div>

    <!-- Contenido del cuarto post -->
    <div id="post_holonomico_4" class="post-container" style="display: none;">
        <h2> Seguimiento de L铆nea con PID en Unibotics - D铆a 4</h2>
        <p>En esta iteraci贸n, hemos introducido un controlador PID adicional para gestionar la velocidad del coche. Ahora, el coche no solo sigue la l铆nea con precisi贸n, sino que tambi茅n ajusta su velocidad en funci贸n de la curvatura de la pista.</p>
        
        <h2> Mejoras con respecto al D铆a 3</h2>
        <ul>
            <li><strong>PID para la Velocidad:</strong> Implementamos un segundo controlador PID que reduce la velocidad cuando el coche entra en curvas y la aumenta en rectas.</li>
            <li><strong>Optimizaci贸n del PID del Volante:</strong> Ajustamos los valores de Kp, Ki y Kd para mejorar la respuesta del coche en curvas.</li>
            <li><strong>Segmentaci贸n Refinada:</strong> Se sigue usando la franja superior de la imagen, pero se ha ajustado el porcentaje de recorte para mejorar la detecci贸n.</li>
            <li><strong>Estrategia de Recuperaci贸n Mejorada:</strong> Ahora el coche alterna entre b煤squeda oscilante y recuperaci贸n de la 煤ltima direcci贸n conocida cuando pierde la l铆nea.</li>
        </ul>
        
        <h2> Resultados y Observaciones</h2>
        <p>Gracias a la nueva implementaci贸n del PID de velocidad, el coche mantiene una conducci贸n m谩s fluida y optimizada, reduciendo la inestabilidad en curvas. Aun as铆, todav铆a hay margen de mejora en la calibraci贸n del PID para minimizar oscilaciones en rectas.</p>
        
        <h2> Pr贸ximos Pasos</h2>
        <ul>
            <li> Refinar a煤n m谩s los valores del PID para obtener una respuesta m谩s natural.</li>
            <li> Explorar m茅todos de predicci贸n de curvas para anticipar mejor los cambios de direcci贸n.</li>
            <li> Optimizar la l贸gica de recuperaci贸n cuando el coche pierde la l铆nea.</li>
        </ul>
    </div>

    <!-- Contenido del quinto post -->
    <div id="post_holonomico_5" class="post-container" style="display: none;">
        <h2> Seguimiento de L铆nea con PID en Unibotics - D铆a 5</h2>
        <p>En esta iteraci贸n, hemos optimizado el controlador PID de velocidad para mejorar la estabilidad del coche en curvas largas y evitar frenados bruscos.</p>
        
        <h2> Mejoras con respecto al D铆a 4</h2>
        <ul>
            <li><strong>Optimizaci贸n del PID de velocidad:</strong> Se ha ajustado la ganancia derivativa (<code>Kd_v</code>) para suavizar la transici贸n entre rectas y curvas.</li>
            <li><strong>Control m谩s gradual:</strong> Ahora la reducci贸n de velocidad en curvas largas es menos abrupta, lo que mejora la estabilidad.</li>
            <li><strong>Mejor respuesta en cambios de direcci贸n:</strong> Se ha refinado el c谩lculo del error para que el coche se ajuste de forma m谩s progresiva.</li>
            <li><strong>Estrategia de recuperaci贸n mejorada:</strong> Se han hecho ajustes en la l贸gica de b煤squeda cuando el coche pierde la l铆nea.</li>
        </ul>
        
        <h2> Resultados y Observaciones</h2>
        <p>Los nuevos ajustes han mejorado la estabilidad general del coche, reduciendo las oscilaciones en rectas y mejorando el comportamiento en curvas. Sin embargo, a煤n es necesario afinar la calibraci贸n del PID para optimizar la respuesta en distintos tipos de curvas.</p>
        
        <h2> Pr贸ximos Pasos</h2>
        <ul>
            <li> Ajustar los valores de PID para una conducci贸n a煤n m谩s fluida.</li>
            <li> Explorar m茅todos avanzados para predecir curvas y mejorar la anticipaci贸n.</li>
            <li> Implementar estrategias adicionales para mejorar la estabilidad a altas velocidades.</li>
        </ul>
    </div>

    <!-- Contenido del sexto post -->
    <div id="post_holonomico_6" class="post-container" style="display: none;">
        <h2> Seguimiento de L铆nea con PID en Unibotics - D铆a 6</h2>
        <p>En esta nueva iteraci贸n, hemos refinado a煤n m谩s el control del veh铆culo para mejorar su estabilidad y anticipaci贸n en las curvas.</p>
        
        <h2> Mejoras con respecto al D铆a 5</h2>
        <ul>
            <li><strong>Implementaci贸n de una franja m谩s elevada:</strong> Ahora el coche analiza la l铆nea roja en una franja a煤n m谩s alta, permiti茅ndole anticiparse mejor a las curvas.</li>
            <li><strong>Optimizaci贸n de la velocidad:</strong> Se ha ajustado el PID de velocidad para permitir una mejor respuesta en curvas y en rectas.</li>
            <li><strong>Nuevo c谩lculo de 谩ngulo:</strong> Se ha a帽adido un m茅todo para calcular la inclinaci贸n de la l铆nea roja a partir de dos puntos de referencia.</li>
            <li><strong>Ajustes en la l贸gica de recuperaci贸n:</strong> El sistema de b煤squeda oscilante se ha refinado para evitar p茅rdidas innecesarias de tiempo cuando la l铆nea se pierde moment谩neamente.</li>
        </ul>
        
        <h2> Resultados y Observaciones</h2>
        <p>Con estas mejoras, el coche mantiene una mayor estabilidad y reacciona de manera m谩s precisa ante cambios en la trayectoria.</p>
        
        <h2> Pr贸ximos Pasos</h2>
        <ul>
            <li> Ajustar los valores del PID para mejorar la respuesta en entornos m谩s din谩micos.</li>
            <li> Implementar un modelo de predicci贸n para anticipar cambios bruscos en la direcci贸n.</li>
        </ul>
    </div>

    <!-- Contenido del s茅ptimo post -->
    <div id="post_holonomico_7" class="post-container" style="display: none;">
        <h2> Seguimiento de L铆nea con PID en Unibotics - D铆a 7</h2>
        <p>En esta iteraci贸n, hemos introducido mejoras significativas en la detecci贸n de la l铆nea roja y en la gesti贸n de la velocidad del coche. Se ha refinado la forma en que se calcula el error para la velocidad y la correcci贸n del volante.</p>
        
        <h2> Mejoras con respecto al D铆a 6</h2>
        <ul>
            <li><strong>Se sigue con la misma estrategia de c谩lculo de velocidad:</strong> Se basa en la inclinaci贸n de la l铆nea en dos franjas de la imagen, permitiendo detectar curvas con mayor anticipaci贸n.</li>
            <li><strong>Optimizaci贸n del PID del Volante:</strong> Ajustamos los valores de Kp, Ki y Kd para mejorar la respuesta del coche en curvas m谩s cerradas.</li>
            <li><strong>Selecci贸n m谩s precisa de franjas para detecci贸n:</strong> Se ajustaron los valores de recorte en la imagen para detectar mejor la posici贸n de la l铆nea.</li>
        </ul>
        
        <h2> Resultados y Observaciones</h2>
        <p>El coche ahora tiene una mejor estabilidad y anticipaci贸n en curvas. La detecci贸n basada en la inclinaci贸n de la l铆nea ha reducido la oscilaci贸n en rectas y ha mejorado la adaptaci贸n de la velocidad.</p>
        
        <h2> Pr贸ximos Pasos</h2>
        <ul>
            <li> Refinar a煤n m谩s los valores del PID para mejorar la suavidad de la conducci贸n.</li>
            <li> Implementar una recuperaci贸n m谩s agresiva cuando el coche pierde completamente la l铆nea.</li>
        </ul>
    </div>

    <!-- Contenido del octavo post -->
    <div id="post_holonomico_8" class="post-container" style="display: none;">
        <h2> Versi贸n Final del Controlador PID - D铆a 8</h2>
        <p>Tras m煤ltiples iteraciones y pruebas, hemos llegado a la versi贸n final del controlador PID para el coche holon贸mico en Unibotics. Se intent贸 volver a la implementaci贸n basada en la diferencia entre el centroide y el centro del frame, pero la estrategia basada en el 谩ngulo de inclinaci贸n de la l铆nea result贸 ser la m谩s estable.</p>
        
        <h2> Mejoras finales en el controlador PID</h2>
        <ul>
            <li><strong>Optimizaci贸n de valores de PID:</strong> Se realizaron ajustes finos a <code>Kp</code>, <code>Ki</code> y <code>Kd</code> tanto en el control del volante como en la velocidad, logrando una respuesta m谩s suave y precisa.</li>
            <li><strong>Uso de la inclinaci贸n de la l铆nea roja:</strong> Se mantiene el c谩lculo del error a partir de la inclinaci贸n de la l铆nea en diferentes franjas, lo que mejora la estabilidad en curvas.</li>
            <li><strong>Correcci贸n de velocidad con PID:</strong> La velocidad ahora se ajusta de manera din谩mica en funci贸n del 谩ngulo de la l铆nea, lo que evita frenadas bruscas y mejora la fluidez.</li>
            <li><strong>Estrategia de b煤squeda refinada:</strong> Se mejor贸 la l贸gica de recuperaci贸n cuando el coche pierde la l铆nea, aumentando la eficiencia en la reorientaci贸n.</li>
        </ul>

	<h2> Resultado Final: Coche Holon贸mico - D铆a 8</h2>
        <p>Este es el resultado final de nuestro coche holon贸mico tras todas las iteraciones y ajustes del controlador PID.</p>
        <p>Despu茅s de varias pruebas y ajustes, logramos optimizar la respuesta del coche, asegurando una estabilidad adecuada en el seguimiento de la l铆nea roja. A continuaci贸n, puedes ver el resultado final en acci贸n:</p>
        
        <iframe width="560" height="315" src="https://www.youtube.com/embed/ag51oN5cGHg" frameborder="0" allowfullscreen></iframe>

	<p>Se logr贸 la estabilidad del control del coche para una velocidad m谩xima del m贸vil de 15 m/s y m铆nima de 7 m/s, alcanzando la vuelta completa en 73 segundos. 
	
        <h2> Observaciones Finales</h2>
        <p>Con estos ajustes, el coche ahora sigue la l铆nea roja con alta precisi贸n y estabilidad. La estrategia basada en el 谩ngulo ha demostrado ser m谩s efectiva que la basada en la posici贸n del centroide, permitiendo mejor anticipaci贸n en curvas y una conducci贸n m谩s fluida.</p>
        
        <h2> Conclusi贸n y Pr贸ximos Pasos</h2>
        <ul>
            <li> Implementar una versi贸n mejorada del control para coches Ackerman.</li>
            <li> Explorar el uso de redes neuronales o algoritmos de aprendizaje autom谩tico para mejorar la predicci贸n del camino.</li>
            <li> Integrar detecci贸n de obst谩culos y ajustes en tiempo real.</li>
        </ul>
        
        <p> 隆Este ha sido un gran avance en el control del coche holon贸mico! 驴Qu茅 opinas de los resultados? </p>
    </div>

    <!-- Contenido del primer post sobre el coche Ackerman -->
    <div id="post_ackerman_1" class="post-container" style="display: none;">
        <h2> Introducci贸n al Coche Ackerman - Primera Iteraci贸n</h2>
        <p>Despu茅s de haber implementado exitosamente el controlador PID para el coche holon贸mico, hemos decidido adaptar este sistema para el coche tipo Ackerman. Esto nos permitir谩 evaluar c贸mo el control PID se comporta en un sistema con restricciones en la direcci贸n.</p>
        
        <h2> Principales diferencias con el coche holon贸mico</h2>
        <ul>
            <li><strong>Sistema de direcci贸n restringida:</strong> A diferencia del holon贸mico, el coche Ackerman solo puede girar cambiando el 谩ngulo de las ruedas delanteras.</li>
            <li><strong>Adaptaci贸n del PID:</strong> Se ajustaron las constantes del PID para manejar mejor la din谩mica del Ackerman.</li>
            <li><strong>Manejo de velocidad optimizado:</strong> La velocidad ahora se adapta en funci贸n de la curvatura detectada para evitar derrapes.</li>
        </ul>
        
        <h2> Implementaci贸n inicial</h2>
        <p>En esta primera iteraci贸n, hemos mantenido la estrategia de detecci贸n de la l铆nea roja usando OpenCV y segmentaci贸n en HSV. Tambi茅n implementamos el c谩lculo de la inclinaci贸n de la l铆nea para ajustar la velocidad en tiempo real.</p>
        
        <h2> Pr贸ximos pasos</h2>
        <ul>
            <li> Refinar los valores del PID para mejorar la respuesta del coche en curvas cerradas.</li>
            <li> Implementar una estrategia de recuperaci贸n en caso de que el coche pierda la l铆nea.</li>
            <li> Ajustar el modelo para mejorar la estabilidad en rectas y transiciones suaves en curvas.</li>
        </ul>      
    </div>

    <!-- Contenido del segundo post sobre el coche Ackerman -->
    <div id="post_ackerman_2" class="post-container" style="display: none;">
        <h2> Simplificaci贸n del C谩lculo del Error - Segunda Iteraci贸n</h2>
        <p>En esta nueva versi贸n del controlador PID para el coche Ackerman, hemos realizado un cambio significativo en la forma en la que calculamos el error para la correcci贸n de direcci贸n y velocidad.</p>
        
        <h2> Principales Cambios</h2>
        <ul>
            <li><strong>Eliminaci贸n del c谩lculo basado en la inclinaci贸n de la l铆nea:</strong> Ahora solo se mide la diferencia del centro de la l铆nea con el centro del frame.</li>
            <li><strong>Simplificaci贸n del c贸digo:</strong> Se redujo la cantidad de c谩lculos, lo que mejora la eficiencia y estabilidad del sistema.</li>
            <li><strong>PID m谩s controlado:</strong> Ajustamos los valores del PID para reducir oscilaciones innecesarias.</li>
        </ul>
        
        <h2> Efectos de este Cambio</h2>
        <p>Gracias a esta simplificaci贸n, el c贸digo ahora es m谩s ligero y eficiente. Sin embargo, esto tambi茅n significa que el coche podr铆a ser menos preciso en curvas cerradas, ya que no anticipa cambios de direcci贸n mediante la inclinaci贸n de la l铆nea roja.</p>
        
        <h2> Pr贸ximos Pasos</h2>
        <ul>
            <li> Evaluar si la simplificaci贸n afecta el rendimiento en circuitos con curvas cerradas.</li>
            <li> Ajustar los valores del PID para optimizar el seguimiento de la l铆nea.</li>
            <li> Explorar la posibilidad de combinar la nueva estrategia con un modelo predictivo.</li>
        </ul>
    </div>

    <!-- Contenido del tercer post sobre el coche Ackerman -->
    <div id="post_ackerman_3" class="post-container" style="display: none;">
        <h2> Introducci贸n de la Banda Muerta - Tercera Iteraci贸n</h2>
        <p>En esta versi贸n del controlador PID para el coche Ackerman, hemos introducido la banda muerta en la correcci贸n de la direcci贸n, lo que permite evitar peque帽as oscilaciones innecesarias en la direcci贸n.</p>
        
        <h2> Principales Mejoras</h2>
        <ul>
            <li><strong>Implementaci贸n de una banda muerta en el control del volante:</strong> Se evita que el coche haga correcciones innecesarias cuando el error es muy peque帽o.</li>
            <li><strong>Ajuste de los valores del PID:</strong> Se increment贸 Kp y Kd para mejorar la estabilidad en curvas.</li>
            <li><strong>Optimizaci贸n de la velocidad:</strong> Se ha ajustado el PID de velocidad para permitir una mayor velocidad en rectas.</li>
        </ul>
        
        <h2> Impacto del Cambio</h2>
        <p>Gracias a la introducci贸n de la banda muerta, el coche ahora es m谩s estable en rectas y no realiza ajustes de direcci贸n innecesarios. Esto ha permitido un incremento en la velocidad m谩xima sin comprometer la estabilidad en curvas.</p>
        
        <h2> Pr贸ximos Pasos</h2>
        <ul>
            <li> Evaluar el rendimiento en circuitos m谩s complejos con diferentes tipos de curvas.</li>
            <li> Ajustar m谩s la banda muerta para lograr un equilibrio 贸ptimo entre estabilidad y respuesta.</li>
            <li> Explorar el uso de estrategias predictivas para anticipar mejor las curvas.</li>
        </ul>
        
    </div>

    <div id="post_ackerman_4" class="post-container" style="display: none;">
        <h2> Versi贸n Final - Cuarta Iteraci贸n</h2>
        <p>Esta es la versi贸n final del controlador PID para el coche Ackerman. Se han realizado los 煤ltimos ajustes para maximizar la estabilidad y eficiencia en el seguimiento de la l铆nea roja.</p>
        
        <h2> Mejoras Finales</h2>
        <ul>
            <li><strong>Optimizaci贸n de Kp y Kd:</strong> Se han ajustado para mejorar la estabilidad y minimizar oscilaciones.</li>
            <li><strong>Aceleraci贸n progresiva:</strong> Implementaci贸n de un factor de aceleraci贸n controlado para evitar cambios bruscos de velocidad.</li>
            <li><strong>Correcci贸n de direcci贸n limitada:</strong> Se estableci贸 un l铆mite en el 谩ngulo de giro para evitar sobrecorrecciones.</li>
        </ul>
        
        <h2> Resultado Final</h2>
        <p>Con esta configuraci贸n, el coche logra un seguimiento de l铆nea estable y eficiente. Se han minimizado los errores de oscilaci贸n y optimizado la adaptaci贸n a curvas.</p>
        
        <h2> Demostraci贸n en Video</h2>
        <p>A continuaci贸n, puedes ver el rendimiento final del coche Ackerman en la pista:</p>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/3Qe5phop2FU" frameborder="0" allowfullscreen></iframe>
        
        <h2> Pr贸ximos Desaf铆os</h2>
        <ul>
            <li> Explorar m茅todos de predicci贸n de trayectorias para mejorar la anticipaci贸n en curvas.</li>
            <li> Integrar detecci贸n de obst谩culos y estrategias de evasi贸n.</li>
            <li> Implementar modelos de aprendizaje autom谩tico para un control m谩s adaptativo.</li>
        </ul>
        
        <p> 驴Qu茅 opinas de los resultados? 隆D茅janos tus comentarios! </p>
    </div>

    <script>
    function mostrarPost(categoria, num) {
        let categorias = ["holonomico", "ackerman"];
        
        // Ocultar todos los posts de ambas categor铆as
        categorias.forEach(cat => {
            for (let i = 1; i <= 9; i++) {
                let post = document.getElementById(`post_${cat}_${i}`);
                if (post) {
                    post.style.opacity = 0;
                    post.style.display = 'none';
                }
            }
        });

        // Mostrar el post seleccionado
        setTimeout(() => {
            let post = document.getElementById(`post_${categoria}_${num}`);
            if (post) {
                post.style.display = 'block';
                setTimeout(() => {
                    post.style.opacity = 1;
                    post.style.transform = 'translateY(0)';
                }, 50);
            }
        }, 200);
    }
</script>

    <!--  Footer al final de la p谩gina -->
    <footer>
        <p><a href="../index.html">Volver a la p谩gina principal</a></p>
    </footer>
</body>
</html>
